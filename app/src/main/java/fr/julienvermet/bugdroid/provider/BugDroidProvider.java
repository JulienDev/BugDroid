/*
* Copyright (C) 2013 Julien Vermet
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package fr.julienvermet.bugdroid.provider;

import java.util.ArrayList;

import android.content.ContentProvider;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.OperationApplicationException;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteStatement;
import android.net.Uri;
import android.provider.BaseColumns;
import android.util.Log;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Accounts;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Attachments;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Bugs;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Ccs;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Comments;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Flags;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Instances;
import fr.julienvermet.bugdroid.provider.BugDroidContent.Products;

/**
 * This class was generated by the ContentProviderCodeGenerator project made by Foxykeep
 * <p>
 * (More information available https://github.com/foxykeep/ContentProviderCodeGenerator)
 */
public final class BugDroidProvider extends ContentProvider {

    private static final String LOG_TAG = BugDroidProvider.class.getSimpleName();

    private static final boolean ACTIVATE_ALL_LOGS = false;

    protected static final String DATABASE_NAME = "BugDroidProvider.db";

    public static final String AUTHORITY = "fr.julienvermet.bugdroid.provider.BugDroidProvider";

    public static final Uri INTEGRITY_CHECK_URI = Uri.parse("content://" + AUTHORITY 
            + "/integrityCheck");

    // Version 1 : Creation of the database
    public static final int DATABASE_VERSION = 1;

    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

	private enum UriType {
        INSTANCES(Instances.TABLE_NAME, Instances.TABLE_NAME, Instances.TYPE_ELEM_TYPE),
        INSTANCES_ID(Instances.TABLE_NAME + "/#", Instances.TABLE_NAME, Instances.TYPE_DIR_TYPE),
        PRODUCTS(Products.TABLE_NAME, Products.TABLE_NAME, Products.TYPE_ELEM_TYPE),
        PRODUCTS_ID(Products.TABLE_NAME + "/#", Products.TABLE_NAME, Products.TYPE_DIR_TYPE),
        ACCOUNTS(Accounts.TABLE_NAME, Accounts.TABLE_NAME, Accounts.TYPE_ELEM_TYPE),
        ACCOUNTS_ID(Accounts.TABLE_NAME + "/#", Accounts.TABLE_NAME, Accounts.TYPE_DIR_TYPE),
        BUGS(Bugs.TABLE_NAME, Bugs.TABLE_NAME, Bugs.TYPE_ELEM_TYPE),
        BUGS_ID(Bugs.TABLE_NAME + "/#", Bugs.TABLE_NAME, Bugs.TYPE_DIR_TYPE),
        COMMENTS(Comments.TABLE_NAME, Comments.TABLE_NAME, Comments.TYPE_ELEM_TYPE),
        COMMENTS_ID(Comments.TABLE_NAME + "/#", Comments.TABLE_NAME, Comments.TYPE_DIR_TYPE),
        ATTACHMENTS(Attachments.TABLE_NAME, Attachments.TABLE_NAME, Attachments.TYPE_ELEM_TYPE),
        ATTACHMENTS_ID(Attachments.TABLE_NAME + "/#", Attachments.TABLE_NAME, Attachments.TYPE_DIR_TYPE),
        FLAGS(Flags.TABLE_NAME, Flags.TABLE_NAME, Flags.TYPE_ELEM_TYPE),
        FLAGS_ID(Flags.TABLE_NAME + "/#", Flags.TABLE_NAME, Flags.TYPE_DIR_TYPE),
        CCS(Ccs.TABLE_NAME, Ccs.TABLE_NAME, Ccs.TYPE_ELEM_TYPE),
        CCS_ID(Ccs.TABLE_NAME + "/#", Ccs.TABLE_NAME, Ccs.TYPE_DIR_TYPE);

        private String mTableName;
        private String mType;

        UriType(String matchPath, String tableName, String type) {
            mTableName = tableName;
            mType = type;
            sUriMatcher.addURI(AUTHORITY, matchPath, ordinal());
        }

        String getTableName() {
            return mTableName;
        }

        String getType() {
            return mType;
        }
    }

    static {
        // Ensures UriType is initialized
        UriType.values();
    }

    private static UriType matchUri(Uri uri) {
        int match = sUriMatcher.match(uri);
        if (match < 0) {
            throw new IllegalArgumentException("Unknown URI " + uri);
        }
        return UriType.class.getEnumConstants()[match];
    }

    private SQLiteDatabase mDatabase;

    @SuppressWarnings("deprecation")
    public synchronized SQLiteDatabase getDatabase(Context context) {
        // Always return the cached database, if we've got one
        if (mDatabase == null || !mDatabase.isOpen()) {
            DatabaseHelper helper = new DatabaseHelper(context, DATABASE_NAME);
            mDatabase = helper.getWritableDatabase();
            if (mDatabase != null) {
                mDatabase.setLockingEnabled(true);
            }
		}

        return mDatabase;
    }

    private class DatabaseHelper extends SQLiteOpenHelper {

        DatabaseHelper(Context context, String name) {
            super(context, name, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            Log.d(LOG_TAG, "Creating BugDroidProvider database");

            // Create all tables here; each class has its own method
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Instances | createTable start");
            }
            Instances.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Instances | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Products | createTable start");
            }
            Products.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Products | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Accounts | createTable start");
            }
            Accounts.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Accounts | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Bugs | createTable start");
            }
            Bugs.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Bugs | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Comments | createTable start");
            }
            Comments.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Comments | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Attachments | createTable start");
            }
            Attachments.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Attachments | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Flags | createTable start");
            }
            Flags.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Flags | createTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Ccs | createTable start");
            }
            Ccs.createTable(db);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Ccs | createTable end");
            }
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

            // Upgrade all tables here; each class has its own method
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Instances | upgradeTable start");
            }
            Instances.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Instances | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Products | upgradeTable start");
            }
            Products.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Products | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Accounts | upgradeTable start");
            }
            Accounts.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Accounts | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Bugs | upgradeTable start");
            }
            Bugs.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Bugs | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Comments | upgradeTable start");
            }
            Comments.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Comments | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Attachments | upgradeTable start");
            }
            Attachments.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Attachments | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Flags | upgradeTable start");
            }
            Flags.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Flags | upgradeTable end");
            }
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Ccs | upgradeTable start");
            }
            Ccs.upgradeTable(db, oldVersion, newVersion);
            if (ACTIVATE_ALL_LOGS) {
                Log.d(LOG_TAG, "Ccs | upgradeTable end");
            }
        }

        @Override
        public void onOpen(SQLiteDatabase db) {
        }
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {

        UriType uriType = matchUri(uri);
        Context context = getContext();

        // Pick the correct database for this operation
        SQLiteDatabase db = getDatabase(context);
        String id = "0";

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "delete: uri=" + uri + ", match is " + uriType.name());
        }

        int result = -1;

        switch (uriType) {
            case INSTANCES_ID:
            case PRODUCTS_ID:
            case ACCOUNTS_ID:
            case BUGS_ID:
            case COMMENTS_ID:
            case ATTACHMENTS_ID:
            case FLAGS_ID:
            case CCS_ID:
                id = uri.getPathSegments().get(1);
                result = db.delete(uriType.getTableName(), whereWithId(id, selection), 
                        selectionArgs);
                break;
            case INSTANCES:
            case PRODUCTS:
            case ACCOUNTS:
            case BUGS:
            case COMMENTS:
            case ATTACHMENTS:
            case FLAGS:
            case CCS:
                result = db.delete(uriType.getTableName(), selection, selectionArgs);
                break;
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return result;
    }

    @Override
    public String getType(Uri uri) {
        return matchUri(uri).getType();
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {

        UriType uriType = matchUri(uri);
        Context context = getContext();

        // Pick the correct database for this operation
        SQLiteDatabase db = getDatabase(context);
        long id;

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "insert: uri=" + uri + ", match is " + uriType.name());
        }

        Uri resultUri = null;

        switch (uriType) {
            case INSTANCES:
            case PRODUCTS:
            case ACCOUNTS:
            case BUGS:
            case COMMENTS:
            case ATTACHMENTS:
            case FLAGS:
            case CCS:
                id = db.insert(uriType.getTableName(), "foo", values);
                resultUri = id == -1 ? null : ContentUris.withAppendedId(uri, id);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        // Notify with the base uri, not the new uri (nobody is watching a new
        // record)
        getContext().getContentResolver().notifyChange(uri, null);
        return resultUri;
    }

    @Override
    public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations) 
            throws OperationApplicationException {
        SQLiteDatabase db = getDatabase(getContext());
        db.beginTransaction();
        try {
            int numOperations = operations.size();
            ContentProviderResult[] results = new ContentProviderResult[numOperations];
            for (int i = 0; i < numOperations; i++) {
                results[i] = operations.get(i).apply(this, results, i);
                db.yieldIfContendedSafely();
            }
            db.setTransactionSuccessful();
            return results;
        } finally {
            db.endTransaction();
        }
    }

    @Override
    public int bulkInsert(Uri uri, ContentValues[] values) {

        UriType uriType = matchUri(uri);
        Context context = getContext();

        // Pick the correct database for this operation
        SQLiteDatabase db = getDatabase(context);

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + ", match is " + uriType.name());
        }

        int numberInserted = 0;
        SQLiteStatement insertStmt;

        db.beginTransaction();
        try {
            switch (uriType) {
                case INSTANCES:
                    insertStmt = db.compileStatement(Instances.getBulkInsertString());
                    for (ContentValues value : values) {
                        Instances.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case PRODUCTS:
                    insertStmt = db.compileStatement(Products.getBulkInsertString());
                    for (ContentValues value : values) {
                        Products.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case ACCOUNTS:
                    insertStmt = db.compileStatement(Accounts.getBulkInsertString());
                    for (ContentValues value : values) {
                        Accounts.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case BUGS:
                    insertStmt = db.compileStatement(Bugs.getBulkInsertString());
                    for (ContentValues value : values) {
                        Bugs.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case COMMENTS:
                    insertStmt = db.compileStatement(Comments.getBulkInsertString());
                    for (ContentValues value : values) {
                        Comments.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case ATTACHMENTS:
                    insertStmt = db.compileStatement(Attachments.getBulkInsertString());
                    for (ContentValues value : values) {
                        Attachments.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case FLAGS:
                    insertStmt = db.compileStatement(Flags.getBulkInsertString());
                    for (ContentValues value : values) {
                        Flags.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                case CCS:
                    insertStmt = db.compileStatement(Ccs.getBulkInsertString());
                    for (ContentValues value : values) {
                        Ccs.bindValuesInBulkInsert(insertStmt, value);
                        insertStmt.execute();
                        insertStmt.clearBindings();
                    }
                    insertStmt.close();
                    db.setTransactionSuccessful();
                    numberInserted = values.length;

			        if (ACTIVATE_ALL_LOGS) {
			            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + " | nb inserts : " + numberInserted);
			        }
                    break;

                default:
                    throw new IllegalArgumentException("Unknown URI " + uri);
            }
        } finally {
            db.endTransaction();
        }

        // Notify with the base uri, not the new uri (nobody is watching a new
        // record)
        context.getContentResolver().notifyChange(uri, null);
        return numberInserted;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, 
            String sortOrder) {

        Cursor c = null;
        Uri notificationUri = BugDroidContent.CONTENT_URI;
        UriType uriType = matchUri(uri);
        Context context = getContext();
        // Pick the correct database for this operation
        SQLiteDatabase db = getDatabase(context);
        String id;

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "query: uri=" + uri + ", match is " + uriType.name());
        }

        switch (uriType) {
            case INSTANCES_ID:
            case PRODUCTS_ID:
            case ACCOUNTS_ID:
            case BUGS_ID:
            case COMMENTS_ID:
            case ATTACHMENTS_ID:
            case FLAGS_ID:
            case CCS_ID:
                id = uri.getPathSegments().get(1);
                c = db.query(uriType.getTableName(), projection, whereWithId(id, selection),
                        selectionArgs, null, null, sortOrder);
                break;
            case INSTANCES:
            case PRODUCTS:
            case ACCOUNTS:
            case BUGS:
            case COMMENTS:
            case ATTACHMENTS:
            case FLAGS:
            case CCS:
                c = db.query(uriType.getTableName(), projection, selection, selectionArgs,
                        null, null, sortOrder);
                break;
        }

        if ((c != null) && !isTemporary()) {
            c.setNotificationUri(getContext().getContentResolver(), notificationUri);
        }
        return c;
    }

    private String whereWithId(String id, String selection) {
        StringBuilder sb = new StringBuilder(256);
        sb.append(BaseColumns._ID);
        sb.append(" = ");
        sb.append(id);
        if (selection != null) {
            sb.append(" AND (");
            sb.append(selection);
            sb.append(')');
        }
        return sb.toString();
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {

        UriType uriType = matchUri(uri);
        Context context = getContext();

        // Pick the correct database for this operation
        SQLiteDatabase db = getDatabase(context);

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "update: uri=" + uri + ", match is " + uriType.name());
        }

        int result = -1;

        switch (uriType) {
            case INSTANCES_ID:
            case PRODUCTS_ID:
            case ACCOUNTS_ID:
            case BUGS_ID:
            case COMMENTS_ID:
            case ATTACHMENTS_ID:
            case FLAGS_ID:
            case CCS_ID:
                String id = uri.getPathSegments().get(1);
                result = db.update(uriType.getTableName(), values, whereWithId(id, selection),
                        selectionArgs);
                break;
            case INSTANCES:
            case PRODUCTS:
            case ACCOUNTS:
            case BUGS:
            case COMMENTS:
            case ATTACHMENTS:
            case FLAGS:
            case CCS:
                result = db.update(uriType.getTableName(), values, selection, selectionArgs);
                break;
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return result;
    }

    @Override
    public boolean onCreate() {
        return true;
    }
}
